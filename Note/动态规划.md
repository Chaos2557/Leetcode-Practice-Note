# 动态规划
动态规划是一个较为复杂，同时也频次较高的考点，一般作为一套算法题中压轴的几道题之一。
## [70. 爬楼梯(Leetcode链接)](https://leetcode-cn.com/problems/climbing-stairs/)
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
示例 2：
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```
## 解题思路
该题有一个基本的关系是：爬到每一层楼梯的方法数等于爬到前两层和前一层楼梯的方法数之和。
比如当前楼为68层，到达该层的上一个步骤有两种可能，一种是66层上两层到68，一种是67层上一层到68。在第一种情况的前提下，出现该情况的可能方法数显然就是直接上到66层的方法数，第二种情况同理。因此，上到68层的方法数即为上到66层的方法数与上到67层的方法数之和。
想明白该推论后，即可发现该题目是一个斐波那契数列，解决方法就可以有很多了。
最快的解决方法当然是利用公式直接计算，但作为算法题来说，我们还是使用动态规划来解决这一问题。

## 代码实现
Python
```
class Solution:
    def climbStairs(self, n: int) -> int:
        x, y, z = 0, 0, 1
        for i in range(n):
            x = y
            y = z
            z = x + y
        return z
```
Java
```
class Solution {
    public int climbStairs(int n) {
        int x = 0, y = 0, z = 1;
        for (int i = 0; i < n; ++i){
            x = y;
            y = z;
            z = x + y;
        }
        return z;
    }
}
```
## [198. 打家劫舍(Leetcode链接)](https://leetcode-cn.com/problems/house-robber/)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
```
输入：[1,2,3,1]  
输出：4  
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。  
```
示例 2：
```
输入：[2,7,9,3,1]  
输出：12  
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。  
```
提示：
* 1 <= nums.length <= 100
* 0 <= nums[i] <= 400
## 解题思路
假设一共有k间房屋，针对于k间房有两种可能性，分别是偷与不偷。  
1. 偷第k间房，代表着不偷第k-1间房，因此偷第k间房的收益即为前k-2间房的最大收益加上第k间房的金额总数。  
2. 不偷第k间房，那么当前情况下最大的收益就等于前k-1间房的最大收益。  
因此，第k间房的最大收益便是上述两种情况中收益最大的那一种。  

## 代码实现
Python
```
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1: return nums[0]
        first, second = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            first, second = second, max(second, first + nums[i])
        return second
```
Java
```
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; ++i){
            int tmp = first;
            first = second;
            second = Math.max(second, tmp + nums[i]);
        }
        return second;
    }
}
```
