# 动态规划
动态规划是一个较为复杂，同时也频次较高的考点，一般作为一套算法题中压轴的几道题之一。
## [70. 爬楼梯(Leetcode链接)](https://leetcode-cn.com/problems/climbing-stairs/)
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
示例 2：
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```
## 解题思路
该题有一个基本的关系是：爬到每一层楼梯的方法数等于爬到前两层和前一层楼梯的方法数之和。
比如当前楼为68层，到达该层的上一个步骤有两种可能，一种是66层上两层到68，一种是67层上一层到68。在第一种情况的前提下，出现该情况的可能方法数显然就是直接上到66层的方法数，第二种情况同理。因此，上到68层的方法数即为上到66层的方法数与上到67层的方法数之和。
想明白该推论后，即可发现该题目是一个斐波那契数列，解决方法就可以有很多了。
最快的解决方法当然是利用公式直接计算，但作为算法题来说，我们还是使用动态规划来解决这一问题。

## 代码实现
Python
```
class Solution:
    def climbStairs(self, n: int) -> int:
        x, y, z = 0, 0, 1
        for i in range(n):
            x = y
            y = z
            z = x + y
        return z
```
Java
```
class Solution {
    public int climbStairs(int n) {
        int x = 0, y = 0, z = 1;
        for (int i = 0; i < n; ++i){
            x = y;
            y = z;
            z = x + y;
        }
        return z;
    }
}
```
